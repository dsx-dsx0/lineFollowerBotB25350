// NO PART OF THIS CODE IS GENERATED BY LLMS. LLMS WERE USED TO LEARN THE CONCEPTS BEHIND THIS CODE, AND ALSO FOR PSEUDO CODE. SOME SYNTAX WAS REFERED FROM 
// GOOGLE, DUE TO MY LACK OF DEEP KNOWLEDGE IN CPP.
// defining and initializing variables/constants that will be used.
int err;
int last_err;
const int basesp = 150; // This is the base value of each motor.
const int sensorMin = 0; // In real sensor, the min and max values will not be the same, and due to this they need to be mapped to fixed min and max values.
// Therefore, if the min and max reading values of real sensors are known, they must be inputed here in an array.
const int sensorMax = 1000;
const int setpoint = 2000; // This is the 'goal' of the PID system. It translates to the sensors aligning to the centre of the black line.
float integral_sum; // Used for calculating the cumulative error.
int errdiff; // used to calulate the difference betweem the current error and the last one.
const int sensorPins[5] = {A0, A1, A2, A3, A4};
void setup() {
  Serial.begin(9600);
  pinMode (A0, INPUT);
  pinMode (A1, INPUT);
  pinMode (A2, INPUT);
  pinMode (A3, INPUT);
  pinMode (A4, INPUT);
  pinMode (5, OUTPUT);   // here, the pins are setup for IO.
  pinMode (6, OUTPUT);
  pinMode (7, OUTPUT);
  pinMode (8, OUTPUT);
  pinMode (11, OUTPUT);
  pinMode (12, OUTPUT);
  
}

void loop() {
  
  int rawValue_0 = analogRead(A0);
  int rawValue_1 = analogRead(A0);
  int rawValue_2 = analogRead(A0);
  int rawValue_3 = analogRead(A0);   // we are taking the raw reading here from the sensors.
  int rawValue_4 = analogRead(A0);
  int mappedValue_0 = map(rawValue_0, sensorMin, sensorMax, 0, 1000);
  int mappedValue_1 = map(rawValue_1, sensorMin, sensorMax, 0, 1000);  // in real life sensors, we will map them to a specific range.
  int mappedValue_2 = map(rawValue_2, sensorMin, sensorMax, 0, 1000);
  int mappedValue_3 = map(rawValue_3, sensorMin, sensorMax, 0, 1000);
  int mappedValue_4 = map(rawValue_4, sensorMin, sensorMax, 0, 1000);
  int position; 
  numerator = (mappedValue_0 * 0) + (mappedValue_1 * 1000) + (mappedValue_2 * 2000) + (mappedValue_3 * 3000) + (mappedValue_4 * 4000);
  denominator = mappedValue_0 + mappedValue_1 + mappedValue_2 + mappedValue_3 + mappedValue_4;
  // the numerator and the denominator are used for calculating the weighted average of the mappings to get the final position.
  // The range of the position will be from 0 to 4000, depending on direction.
  if (denominator == 0) {
    if (last_err < -100){   // the denominator can only be 0 if all the readings are to the min (mapped to 0).
                            // This means the black line, at this point is lost and this can be either due to the bot drifing to the extreme left
      						// or the extreme right. To counter this, the position will be set to the opposite extreme direction.
      position = 0;
      
    }
    
    else if (last_err > 100) {
      
      position = 4000;
      
    }
    else {
      position = setpoint;
      
    }
    
  else {
    
    position = numerator / denominator;
    
  }
    
  err = position - setpoint; // error calculation.
  float Pterm = kp * err;
  
  integral_sum = integral_sum + err;
  float Iterm = ki * integral_sum;
                                            // the final summation (correction_value here) value of PID is calculated here.
  int errdiff = err - last_err;
  float Dterm = kd * errdiff;
    
  last_err = err;
    
  int right_speed = basesp + correction_value;
  int left_speed = basesp - correction_value;
  
  setMotorSpeeds(left_speed, right_speed);   // a function that is defined later.
  
  
}
  
  
void setMotorSpeeds(int ls, int rs) {
  
  int finalLeft = constrain(ls, -255, 255);    // To make sure the leftSpeed and rightSpeed values dont go out of bounds due to correction_value.
  int finalRight = constrain(rs, -255, 255);
  
  if (finalLeft > 0) {
    
    digitalWrite(7, HIGH);
    digitalWrite(8, LOW);      // The digitalWrite funciton is used to select the direction, positive finalLeft means forward direction. 
    analogWrite(5, finalLeft); // The analogWrite function is used to select the precise speed. It only takes positive values, and doesnt 
    						   // determine the direction.
  }
  
  else {
    
    digitalWrite(7, LOW);
    digitalWrite(8, HIGH);
    analogWrite(5, abs(finalLeft));
  }
  
  if (finalRight > 0) {
    
    digitalWrite(11, HIGH);
    digitalWrite(12, LOW);
    analogWrite(6, finalRight);
  }
  else {
    digitalWrite(11, LOW);
    digitalWrite(12, HIGH);
    analogWrite(6, abs(finalRight));
  }
}
    